{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"About"},{"location":"contributors/contributorguide/","text":"Contributers guide \u00b6 1. Version considerations \u00b6 NPM package.json files exist in folders cra-client and cra-server; these packages describe the Egeria React UI client and server respectively. The version defined in these files is intended to match an Egeria version; this is so that Docker images can be constructed with matching levels of this UI and the Egeria to which it is communicating. When Egeria is released with a new version, the versions in the 2 package.json files should match the Egeria version, for example Egeria release z.y.x (e.g. 2.6.0) will match the package.json's which both specify version z.y.x. When the UI code is being developed, the version is z.y-rc.x (2.7-rc.0); the rc indciates that the code is a release candidate (rc) for the next version of Egeria (2.7.0 in this example). Note that the 2 Egeria React UI npm packages are not, at this time, published to NPM. 2 A note to the developers managing the creation of new versions \u00b6 The version in the package.json can be updated using he command 'npm version preminor -preid rc' or can be editted directly in the package.json file. 3. Release Notes \u00b6 Refer to github change history. 4. Project structure \u00b6 This project is a Create React App . 5. cra-server \u00b6 This is the Express server (also known as the presentation server). the cra - stands for Create React app. * db - this is the in memory database used for the simple authentication for demo purposes * functions - common functions * node_modules - dependant node modules * router - the middleware routes that node uses to process incoming requests * validations - validation of incoming content 6. cra-client \u00b6 This is the client code including the javascript. the cra - stands for Create React app. * build - this is where the client code is built for use in production * node_modules - dependant node modules * public - resources * src - source code, containsthe Node app, scss, and the frame in which all the components live. * components - contains the home screen and subfolders for each UI capability component * contexts - React contexts * images - images, javascript wrappers of the the svg images with size. * imagesHolder - this contains the svg images, grouped in folders to indicate their origin 7. There is ongoing work to enable easy running of the Presentation Server in a demo environment \u00b6 The Coco Pharmaceuticals 'lab' tutorial environment will now configure the view services, and allow a user to experiment with the Presentation Server The 'egeria-server-config' notebook has code added to configure the view services - so once this & egeria-server-start is run, Presentation Server is available. The Presentation Server code is built under maven (mvn clean install) & added to a new assembly (open-metadata-distribution/open-metadata-assemblies) as part of the overall build. A new docker image is created as 'odpi/egeria-presentation-server' containing Presentation Server. Our docker-compose based tutorial now has Presentation Server included & configured via the environment variable, and accessed at https://localhost:18091/coco/login . The Kubernetes tutorial 'odpi-egeria-lab' has also been updated similarly, with the Presentation Server UI being acessible via port 30091 - ie access via https:\\<address-of-k8s-node>/coco.login For the lab environment it is recommended to use user 'garygeeke' and password 'admin' since this environment has security setup, and other users including faithbroker will not have access to all capabilities. This is still work in progress. For example if the session times out you will need to go to the UI URL again manually. Contact us via Slack on odpi.slack.com to get additional guidance.","title":"Contributorguide"},{"location":"contributors/contributorguide/#contributers-guide","text":"","title":"Contributers guide"},{"location":"contributors/contributorguide/#1-version-considerations","text":"NPM package.json files exist in folders cra-client and cra-server; these packages describe the Egeria React UI client and server respectively. The version defined in these files is intended to match an Egeria version; this is so that Docker images can be constructed with matching levels of this UI and the Egeria to which it is communicating. When Egeria is released with a new version, the versions in the 2 package.json files should match the Egeria version, for example Egeria release z.y.x (e.g. 2.6.0) will match the package.json's which both specify version z.y.x. When the UI code is being developed, the version is z.y-rc.x (2.7-rc.0); the rc indciates that the code is a release candidate (rc) for the next version of Egeria (2.7.0 in this example). Note that the 2 Egeria React UI npm packages are not, at this time, published to NPM.","title":"1. Version considerations"},{"location":"contributors/contributorguide/#2-a-note-to-the-developers-managing-the-creation-of-new-versions","text":"The version in the package.json can be updated using he command 'npm version preminor -preid rc' or can be editted directly in the package.json file.","title":"2 A note to the developers managing the creation of new versions"},{"location":"contributors/contributorguide/#3-release-notes","text":"Refer to github change history.","title":"3. Release Notes"},{"location":"contributors/contributorguide/#4-project-structure","text":"This project is a Create React App .","title":"4. Project structure"},{"location":"contributors/contributorguide/#5-cra-server","text":"This is the Express server (also known as the presentation server). the cra - stands for Create React app. * db - this is the in memory database used for the simple authentication for demo purposes * functions - common functions * node_modules - dependant node modules * router - the middleware routes that node uses to process incoming requests * validations - validation of incoming content","title":"5. cra-server"},{"location":"contributors/contributorguide/#6-cra-client","text":"This is the client code including the javascript. the cra - stands for Create React app. * build - this is where the client code is built for use in production * node_modules - dependant node modules * public - resources * src - source code, containsthe Node app, scss, and the frame in which all the components live. * components - contains the home screen and subfolders for each UI capability component * contexts - React contexts * images - images, javascript wrappers of the the svg images with size. * imagesHolder - this contains the svg images, grouped in folders to indicate their origin","title":"6. cra-client"},{"location":"contributors/contributorguide/#7-there-is-ongoing-work-to-enable-easy-running-of-the-presentation-server-in-a-demo-environment","text":"The Coco Pharmaceuticals 'lab' tutorial environment will now configure the view services, and allow a user to experiment with the Presentation Server The 'egeria-server-config' notebook has code added to configure the view services - so once this & egeria-server-start is run, Presentation Server is available. The Presentation Server code is built under maven (mvn clean install) & added to a new assembly (open-metadata-distribution/open-metadata-assemblies) as part of the overall build. A new docker image is created as 'odpi/egeria-presentation-server' containing Presentation Server. Our docker-compose based tutorial now has Presentation Server included & configured via the environment variable, and accessed at https://localhost:18091/coco/login . The Kubernetes tutorial 'odpi-egeria-lab' has also been updated similarly, with the Presentation Server UI being acessible via port 30091 - ie access via https:\\<address-of-k8s-node>/coco.login For the lab environment it is recommended to use user 'garygeeke' and password 'admin' since this environment has security setup, and other users including faithbroker will not have access to all capabilities. This is still work in progress. For example if the session times out you will need to go to the UI URL again manually. Contact us via Slack on odpi.slack.com to get additional guidance.","title":"7. There is ongoing work to enable easy running of the Presentation Server in a demo environment"},{"location":"ecosystem/RepositoryExplorerGuide/","text":"The Repository Explorer (Rex) can help you explore and visualize the metadata in a repository. It retrieves entities and relationships from the repository and displays them. A details panel also shows the properties and other information about an object. Each entity or relationship is added to a network diagram, which shows how they are connected. Starting with an initial object - an entity or relationship - Rex enables you to explore the neighborhood of objects around that initial object. It does so by traversing the relationships connected to each entity, and allows you to select what types of relationship and types of neighboring entity you want it to retrieve. You can also filter the traversal by specifying classifications that the neighboring entities must possess. You can repeat this traversal process to assemble a graph of the objects that you are interested in. You don't need to know the available relationship types, entity types or classifications in advance, because Rex will display what is possible and let you choose. In general, one object in the graph is the 'focus'; this is the object from where the next traversal starts; the focus object is the one that is displayed in the details panel. You can set which object is the focus by clicking on it in the diagram. If you retrieve an object from the repository by searching or typing in its GUID, that object automatically becomes the new focus. Rex can retrieve and display objects of the types supported by whichever repository you connect it to. When you connect it to a repository, Rex will automatically read the type information from the repository. It uses this information to populate things like the search filters (explained below). Rex is intended as a tool to help targeted exploration of relatively small sets of entities and relationships. It is not a general graph visualization utility, so it would not be wise to use to construct a large graph. It is advisable to limit the number of traversals you perform, and avoid performing a traversal that would include a large number of objects. There are no hard limits on graph size, but it is recommended that exploration is kept specific and aimed at revealing the structure of relatively small sub-graphs. To help with this, Rex provides assistance to help limit what you get back from each traversal. For example, it provides Traversal Filters that allow you to filter the types of entity and relationship to include. The Traversal Filters work by types and classifications. They do not support fine-grained (property-based) filtering of objects within a traversal. This is not a limitation of Rex, rather a reflection of the functions available in the metadata collection interface. If the type-based filtering provided by Rex's Traversal Filters proves to be too coarse-grained, and you find yourself struggling to select a particular entity within a possible set of neighbors, consider adopting a different approach. For example, it may be better to with a search for the interesting entity, followed by traversing from that entity. It may be possible in future to add more sophisticated traversal filters but there would most likely still be repositories that would not support the full metadata collection interface. A Typical Workflow: Typically you would perform the following steps: Set the repository server details Retrieve one or more initial metadata objects, either using Search or by specifying an object's GUID if you know it Explore starting from the initial object, applying filters at each step Explore from additional objects or using different filters When you have something you want to keep, capture the diagram and history views At any point you can Undo the most recent operation (repeatedly) or can clear the whole graph Set the Repository Server: To get started Rex needs the name and URL of the repository server that you wish to explore. Enter these details in the \"Server Name\" and \"Server URL Root\" fields and press the 'Connect' button. Immediately below the server input fields, you will see a status message. On first start the message asks that you enter the server details and press Connect. Rex will use the server details to request the type information from the repository, which Rex uses to populate its search filters. If the request to the server completes successfully you should see the message change to \"Server OK\". If Rex cannot connect to the server it will display an error message and ask you to check the details and retry. Rex does not maintain a long-running connection to the server; each time it needs to get something from the server it will use the server details you have set. Get some initial metadata: Rex needs an object as the starting point of a traversal. You can retrieve a starting object either by entering a GUID or by performing a Search, which is explained below. If an object is found it will appear in the diagram. If no object could be found you will see an alert pop up. You can start with either an entity or a relationship - use whichever is most convenient. Entities are drawn as circles. Relationships are drawn as lines connecting pairs of circles (entities). Classifications are not shown in the diagram, but any classifications associated with an entity are shown in the details panel when the entity is selected. Setting the focus object: If one object was retrieved it will automatically be set to the focus, so it will be highlighted and its details will be displayed in the details panel. If multiple objects were retrieved they will be shown in the diagram and none will be highlighted. You can select a focus object in the diagram by clicking on it. The focus object will be highlighted in the diagram and its details will be shown in the details panel. The focus object is highlighted in the primary color for the UI - this is the same color used for things like buttons and banners. The default primary color is the Egeria 'aqua' color (a pale blue), but this may be changed if a different color scheme has been applied. Other objects (not the focus) are given a color that reflects the home repository of the object; objects from the same home repository will be the same color. These 'repository colors' are generally shades of gray. If you want to deselect the selected object, click on it again. This can be useful if you want to view the graph with no object focused, so that all objects are shown in their 'repository colors'. Traverse to find related metadata: Once there's an initial object in the diagram, you can use the Explore button to retrieve further objects that are related to the focus object. Rex needs to traverse from an entity, so if you retrieved or selected a relationship, click on one of its entities before attempting to traverse. When you traverse, Rex will explore the neighborhood around the selected entity, traversing outward along the available relationships to find adjacent entities. This process can be repeated to enlarge the graph of entities and relationships that are displayed. Rex currently supports a traversal depth of 1 - meaning it will only traverse as far as the immediate neighbors of the focus entity. It could support deeper traversals, but this would make it harder to understand the traversal filters - so depth is limited to 1. When you press the Explore button, Rex display a set of (optional) traversal filters, that you can set before it actually performs the traversal. This is to let you decide which relationships and entities will be included in the traversal. The traversal filters display the number of relationships and entities of each type, that could be included in the displayed graph. Check the counts and select the types you want. Rex will then only retrieve the objects you are really interested in. There is more information below under \"Traversal Filtering\". Search: The search utility in Rex is fairly basic. It allows you to enter a text string and optionally apply an entity, relationship or classification filter, which limits the search to one particular type. The classification filter is not yet enabled, but that capability should be added soon. The search utility does not include property-based searching, it is just a text-based search. It therefore relies on objects having string-type attributes that can be searched. If an object is of a type that has no string-type attributes then it will not be found by the search. It is possible that property-based searching could be added, but it is not available yet. When you enter a string as search text, it can include regular expression characters. Beware that the level of support for regular expressions varies between repositories. If you are searching an Egeria graph repository or in-memory repository, then you have more freedom than you might have with some other repositories. If the text you are searching for contains special characters, you will need to literalize the string. As an example, suppose there are two Assets called asset-qn001 and asset-(qn001). In this example, the parentheses are special characters, because they affect the processing of the regular expression. If you type asset-qn001 as the search text, the first asset (only) will match. If you type asset-(qn001) as the search text, the first asset (only) will match. If you type \\Qasset-(qn001)\\E in as the search text, the second asset (only) will match. This example was tested using the Egeria graph repository. Some repositories support broad regular expressions but others do not. All repositories should support exact, prefix and suffix matches - so you should be able to use expressions like \\Qany.characters.you.like!\\E.* - which would literalize the part between \\Q and \\E as the beginning of the search expression and permit any other characters to follow it. Traversal Filtering: When you press Explore to expand the neighborhood around an entity, a dialog box will show how many entities and relationships might be included. The number of occurrences of each type of entity or relationship are shown alongside the type name. You can decide which types to include in the traversal. This dialog box also shows numbers of classifications associated with the neighboring entities. The filters are separated into three columns - for entity types, relationship types and classifications, respectively. Each column operates as follows: If none of the types in a column are checked, no filtering is applied to that column. This means that all entity types will be included in the traversal, or all relationship types. If any of the types in a column are checked then filtering is performed. Only the checked types are allowed. If you were to check ALL the types in the entity or relationship columns you achieve the same as when none of the checkboxes in those columns are checked (i.e. when there is no filtering). That is, the traversal will include all entities or all relationships. Note that if you wish to include a relationship to a neighboring entity, you need to enable both the relationship type and the entity type. This allows you to be very specific about which relationships to traverse. If there are relationships of the same type to entities of different types, or vice versa, you can independently select relationship and entity types to achieve finer grain traversal. If no classification types are checked there is no classification filtering. This means all entities will be eligible, regardless of their classifications (if any). Be careful with the classification column - if you check ALL the classification types it does NOT mean that all entities are eligible - it means only those entities that have at least one of the checked classifications will be eligible. If there is a neighboring entity that has none of the classifications it will not be reached. Adding to the graph: If after a number of traversals you realize that you would like to perform an additional traversal from an entity you visited at an earlier stage, just go back and select the entity from which you want to perform the additional traversal. Then press the Explore button. You can set the filters to include the types that you would like to add to the graph. Undoing a change: If you realize that you have added things to the graph that you actually do not want, you can use the Undo button to undo the most recent change. The Undo button can be used repeatedly to unwind back to a state that contains objects you want to keep. You can then use Explore from this state to add more objects. Clearing the graph: The Clear button will clear the graph diagram, the GUID input field and the details panel. It effectively resets Rex to the state it was in when the page was first loaded, apart from the search text. Traversal History: At any point during an exploration session you can use the History button to list the operations that resulted in the graph as it is currently displayed. The traversal history shows the sequence of operations and describes the type and parameters of each operation and the entities and relationships that were added to the graph by each operation. The types of operation include retrieval using a GUID, search and traversal. In each case the GUID, search string or traversal parameters are recorded. Diagram layouts: There is currently one type of diagram - called the 'Network Diagram'. Other types of diagram may be added later. The Network Diagram is a visualization of the traversed graph, in which entities and relationships are drawn as circles and arcs. Each entity or relationship is labelled according to Rex's built-in labelling scheme (see below). The GUID (globally unique id) associated with an instance may be the only way to uniquely identify it, but it is not particularly convenient or memorable. Rex includes the GUID in the details panel and in the traversal history to help to uniquely identify an instance. There are two layout settings within the Network Diagram, that can be selected using the radio button in the top-left corner of the diagram: Time-based (default) layout. This layout places objects starting at the top of the diagram and working vertically downwards with each stage of traversal; the more recently visited objects will be located toward the bottom of the diagram. This layout may be helpful while you are building the diagram. The temporal placement is not rigid - if a relationship connects a pair of entities retrieved in different stages of the traversal, it will tend to pull them together, possibly distorting the temporal sequence. Proximity-based layout. This layout places objects using a straightforward force-directed graph layout. There is no temporal ordering. This layout may be preferred when you have finished adding to the diagram and would like to lay it out for display or printing. You can switch back and forth between the layout options. ** Labelling of objects: Rex has a built-in labeler that assigns a label to each object (entity or relationship) that is retrieved from the repository. The labels are used in the diagram and attempts to find a concise, meaningful and hopefully unique label, based on the properties of the entity or relationship. The labelling strategy behaves differently depending on the type of an object. For some types of object there are not many possible labels, but in the default case Rex will examine the instance properties of the object and choose a label based on the following precedence order: * displayName - which should have been set with the expectation that it will be used for display purposes * name - which should be easier to read than qualified name * qualifiedName - limited to the last 24 characters as qualified names can be long and the last part is often the best means of discrimination. If you retrieve a relationship (from Get or Search), the entities at the ends of the relationship will be assigned labels based on the information available - which is limited to the unique properties in the EntityProxy. If such an entity is subsequently selected (by clicking on it) Rex will retrieve the full entity and if it can identify a better label, it will update the label associated with the entity in both the diagram and in the details panel. Tips for using Rex: Rex uses the Metadata Collection API to interrogate the chosen repository. All Egeria repositories support this API, but some functions of the API are optional, so not all repositories support them. For maximum support for graph traversals, if possible choose a repository server that has the Egeria graph repository. Remember that Egeria servers can create reference copies of objects, so you can ask a server with a graph repository about objects that belong to other repositories in the cohort. Relationship types do not have many attributes; some have no type-defined attributes at all. If you have trouble searching for a relationship, it may be easier to search for an entity that you believe is connected to the relationship. Alternatively, use another tool to retrieve the relationship GUID and paste that into Rex and use the Get button. If you are short of screen space, there a couple of things you can do to save space with Rex: One is to click the 'hamburger' menu icon to toggle away the left-hand navigation menu. Another is that, once you have selected the repository server to use and retrieved the first entity or relationship, you may not need to visit the top part of the screen again, or only infrequently, so try scrolling until the top edge of the diagram and controls are at the top of the browser page. The controls have been placed level with the top of the diagram to enable this. At any point during an exploration session you can use the History button to display a dialog that lists where the exploration started and what steps have been used, to arrive at the graph that is currently displayed. You can save the current diagram as a .png image file, using the button near the top-left of the diagram. Before capturing the image, consider clicking on the currently selected object to remove the focus color, if you want to see its home repository color instead. After capturing the history and image, as described above, it is straightforward to copy and paste them into a report document. Customization: Rex uses a styled set of colors, so it can be re-themed. The important colors are defined as CSS variables in the shared-styles.js file. They are called --egeria-primary-color and --egeria-secondary-color. By setting the egeria-primary-color you can achieve different themes.","title":"RepositoryExplorerGuide"},{"location":"ecosystem/ecosystem/","text":"Egeria ecosystems, consist of platforms, on which servers run; these servers run services and communicate using cohorts. The ecosystem tools allows an infrastructure architect to configure, define, explore, navigate and operate the eco-system. Services work on open types and instances of these open types; these can also be explored using these tools. The ecosystem tools are Type Explorer: allowing a user to explore the Egeria open types RepositoryExplorer : allowing a user to explore Egeria instances Server Author: allowing a user to configure a server. This is work in progress. Dino: allowing a user to see and work with Egeria platforms and servers operationally.","title":"Ecosystem"},{"location":"getting-started/prereqs/","text":"Getting Started - prerequisites \u00b6 Egeria is about integrating metadata from different sources in a peer to peer manner; the open types are the language of this integration. Egeria Solutions can be sophisicated, but to get started with the Egeria React UI you can use a simple setup, with : A Metadata repository server A View server Each user interface capability in the presentation server requires an associated view service. To use a particular UI capability you need to have the equivalient view service configured and active; follow these intructions to set up the view services. The name of the UI capability is the same as the name of the view service. Be aware that a view service has a downstream dependancy as well, for example the Glossary Author View service calls the downstream dependancy Subject Area OMAS , which also needs to be configured and active.","title":"Prereqs"},{"location":"getting-started/prereqs/#getting-started-prerequisites","text":"Egeria is about integrating metadata from different sources in a peer to peer manner; the open types are the language of this integration. Egeria Solutions can be sophisicated, but to get started with the Egeria React UI you can use a simple setup, with : A Metadata repository server A View server Each user interface capability in the presentation server requires an associated view service. To use a particular UI capability you need to have the equivalient view service configured and active; follow these intructions to set up the view services. The name of the UI capability is the same as the name of the view service. Be aware that a view service has a downstream dependancy as well, for example the Glossary Author View service calls the downstream dependancy Subject Area OMAS , which also needs to be configured and active.","title":"Getting Started - prerequisites"},{"location":"getting-started/setup/","text":"Setup \u00b6 Ensure you have set up the Egeria servers you need to run the UI. A simple setup is described here . 1. Obtain the Egeria React user interface \u00b6 Start by downloading the Egeria React User Interface: Latest release Release 2.11.0 The released user interface is supplied in an archive, containing the source code as a zip or tar.gz file, which you need to extract. Development git clone the repository using the instructions under the Code button at Latest code You now have a folder on your machine with the user interface code extracted. 2. The presentation server environment variable \u00b6 The presentation server is the node application for the user applicaiton. It serves the web pages, proxies therest calls andhandles the login. For a particular tentant thepresentation server needs to know which back end servr to send requests to. This information is supplied in an environment variable(s). The environment variable is: EGERIA_PRESENTATIONSERVER_SERVER_\\<localServerName>={\"remoteServerName\":\"\\<remoteServerName>\",\"remoteURL\":\"\\<remoteURL>\"} where <localServerName> should be replaced with the local server name. This segment is the start segment of the url that the browser sends. <remoteServerName> should be replaced with the remote server name. This is the name of the view service that has been configured in the view server. <remoteURL> should be replaced with the remote server URL. This is the URL of the view service. Since this environment variable is typically handled by the shell and includes a json fragment, when setting it you need to be sure to 'escape' quotation characters, so you would type: EGERIA_PRESENTATIONSERVER_SERVER_aaa = \"{\\\"remoteServerName\\\":\\\"cocoView1\\\",\\\"remoteURL\\\":\\\"https://localhost:9443\\\"}\" We can see this is set as we expect ``` $ echo $EGERIA_PRESENTATIONSERVER_SERVER_aaa To get an initial environment up-and-running just download the truststore.p12 file from: https://github.com/odpi/egeria/raw/master/truststore.p12 . Transport-level security The truststore.p12 file provides a local truststore for Java. This allows the self-signed certificate embedded within the server chassis (by default) to be trusted. Without this trust, interactions with the server chassis (such as the REST calls that are made through Java to handle interaction between the chassis and the connector) will result in an SSLHandshakeException . While this truststore.p12 file allows SSL-encrypted communication, the fact that it relies on a self-signed certificate means that there is no independent source of trust in the interactions (which would typically be achieved through an independent Certificate Authority). Additional details on TLS for Egeria can be found in the Egeria documentation . 3. Running the presentation server \u00b6 To run on a different machine, copy over the cra-client and cra-server/build folders, maintaining their relative locations to the target machine. Once you have the code where you want to run it: Navigate to the cra-client folder and run npm install Navigate to the cra-server folder and run npm install In production mode To run the presentation server in production mode, the javascipt and resources need to be minified . Navigate into cra-client , then run npm run build . The cra-client folder now should contain a build folder containing the artifiacts to run in production. Run npm run prod in the cra-server folder . In development mode Navigate into cra-server and run npm start . After a couple of minutes while it builds, for tenant aaa, you should be able to login. 4. Demo login \u00b6 If you have used the sample environment variables and are using the Egeria Dojo setup , then you can login as follows. In your web browser go to https://localhost:9443/aaa/ (Replace host/port accordingly) In this example aaa is the tenant name we used above when defining the environment variable The trailing / is currently required to allow the login page to load For ecosystem tools use user 'garygeeke' and password 'admin'. For glossary author use user 'faithbroker' and password 'admin'. 5. SSL configuration \u00b6 By default the Egeria React UI uses a truststore.p12 and keystore.p12 files for ssl. The p12 files are copies of files 'https://github.com/odpi/egeria/blob/master/keystore.p12' and 'https://github.com/odpi/egeria/blob/master/truststore.p12', which are the definitive sources of these files. The keystore and truststore files allow Egeria to run simply in a demo/development; this is not appropriate for production, which should be appropriately secured.","title":"Setup"},{"location":"getting-started/setup/#setup","text":"Ensure you have set up the Egeria servers you need to run the UI. A simple setup is described here .","title":"Setup"},{"location":"getting-started/setup/#1-obtain-the-egeria-react-user-interface","text":"Start by downloading the Egeria React User Interface: Latest release Release 2.11.0 The released user interface is supplied in an archive, containing the source code as a zip or tar.gz file, which you need to extract. Development git clone the repository using the instructions under the Code button at Latest code You now have a folder on your machine with the user interface code extracted.","title":"1. Obtain the Egeria React user interface"},{"location":"getting-started/setup/#2-the-presentation-server-environment-variable","text":"The presentation server is the node application for the user applicaiton. It serves the web pages, proxies therest calls andhandles the login. For a particular tentant thepresentation server needs to know which back end servr to send requests to. This information is supplied in an environment variable(s). The environment variable is: EGERIA_PRESENTATIONSERVER_SERVER_\\<localServerName>={\"remoteServerName\":\"\\<remoteServerName>\",\"remoteURL\":\"\\<remoteURL>\"} where <localServerName> should be replaced with the local server name. This segment is the start segment of the url that the browser sends. <remoteServerName> should be replaced with the remote server name. This is the name of the view service that has been configured in the view server. <remoteURL> should be replaced with the remote server URL. This is the URL of the view service. Since this environment variable is typically handled by the shell and includes a json fragment, when setting it you need to be sure to 'escape' quotation characters, so you would type: EGERIA_PRESENTATIONSERVER_SERVER_aaa = \"{\\\"remoteServerName\\\":\\\"cocoView1\\\",\\\"remoteURL\\\":\\\"https://localhost:9443\\\"}\" We can see this is set as we expect ``` $ echo $EGERIA_PRESENTATIONSERVER_SERVER_aaa To get an initial environment up-and-running just download the truststore.p12 file from: https://github.com/odpi/egeria/raw/master/truststore.p12 . Transport-level security The truststore.p12 file provides a local truststore for Java. This allows the self-signed certificate embedded within the server chassis (by default) to be trusted. Without this trust, interactions with the server chassis (such as the REST calls that are made through Java to handle interaction between the chassis and the connector) will result in an SSLHandshakeException . While this truststore.p12 file allows SSL-encrypted communication, the fact that it relies on a self-signed certificate means that there is no independent source of trust in the interactions (which would typically be achieved through an independent Certificate Authority). Additional details on TLS for Egeria can be found in the Egeria documentation .","title":"2. The presentation server environment variable"},{"location":"getting-started/setup/#3-running-the-presentation-server","text":"To run on a different machine, copy over the cra-client and cra-server/build folders, maintaining their relative locations to the target machine. Once you have the code where you want to run it: Navigate to the cra-client folder and run npm install Navigate to the cra-server folder and run npm install In production mode To run the presentation server in production mode, the javascipt and resources need to be minified . Navigate into cra-client , then run npm run build . The cra-client folder now should contain a build folder containing the artifiacts to run in production. Run npm run prod in the cra-server folder . In development mode Navigate into cra-server and run npm start . After a couple of minutes while it builds, for tenant aaa, you should be able to login.","title":"3. Running the presentation server"},{"location":"getting-started/setup/#4-demo-login","text":"If you have used the sample environment variables and are using the Egeria Dojo setup , then you can login as follows. In your web browser go to https://localhost:9443/aaa/ (Replace host/port accordingly) In this example aaa is the tenant name we used above when defining the environment variable The trailing / is currently required to allow the login page to load For ecosystem tools use user 'garygeeke' and password 'admin'. For glossary author use user 'faithbroker' and password 'admin'.","title":"4.  Demo login"},{"location":"getting-started/setup/#5-ssl-configuration","text":"By default the Egeria React UI uses a truststore.p12 and keystore.p12 files for ssl. The p12 files are copies of files 'https://github.com/odpi/egeria/blob/master/keystore.p12' and 'https://github.com/odpi/egeria/blob/master/truststore.p12', which are the definitive sources of these files. The keystore and truststore files allow Egeria to run simply in a demo/development; this is not appropriate for production, which should be appropriately secured.","title":"5. SSL configuration"},{"location":"overview/Overview/","text":"Egeria React UI Overview \u00b6 The Egeria React UI isa React multi tenant User Interface for Open Metadata and Governance. It is part of the Egeria project; as such it is bound by the same code of conduct, governance etc and it part of the Egeria community (and community calls). This Git repository contains the Egeria React User Interface (UI), which provides a multi tenanted, persona based interface for users to work with Egeria solutions and Egeria ecosystem tools. This repository is separate from the main Egeria repository, because the technology and build infrastructure is sufficiently different for the User interface. Egeria React User Interface developers work with nodejs, develop in javascript, use the React framework and use npm; whereas the main Egeria repository attracts developers with Java skills. The Presentation Server is a multi-tenant persona based server that serves a user interface - it issues rest calls downstream primarily to view servers See the Egeria Planning guide to familiarise yourself with the types of Egeria OMAG Servers . There is an Egeria tutorial on setting up Egeria servers can be following Egeria Dojo , but this does not detail the parts to do with the presentation server and this UI. There are 2 types of capabilities in the Presentation Server. Ecosystem Tools Solutions","title":"Overview"},{"location":"overview/Overview/#egeria-react-ui-overview","text":"The Egeria React UI isa React multi tenant User Interface for Open Metadata and Governance. It is part of the Egeria project; as such it is bound by the same code of conduct, governance etc and it part of the Egeria community (and community calls). This Git repository contains the Egeria React User Interface (UI), which provides a multi tenanted, persona based interface for users to work with Egeria solutions and Egeria ecosystem tools. This repository is separate from the main Egeria repository, because the technology and build infrastructure is sufficiently different for the User interface. Egeria React User Interface developers work with nodejs, develop in javascript, use the React framework and use npm; whereas the main Egeria repository attracts developers with Java skills. The Presentation Server is a multi-tenant persona based server that serves a user interface - it issues rest calls downstream primarily to view servers See the Egeria Planning guide to familiarise yourself with the types of Egeria OMAG Servers . There is an Egeria tutorial on setting up Egeria servers can be following Egeria Dojo , but this does not detail the parts to do with the presentation server and this UI. There are 2 types of capabilities in the Presentation Server. Ecosystem Tools Solutions","title":"Egeria React UI Overview"},{"location":"solutions/solutions/","text":"These are user interface capabilities allowing particular personas to work with Egeria Solutions . The solutions that are being developed are: GlossaryAuthor : allowing a Glossary Author persona to create, update and delete Glossary content. The expectation is that more solutions will be developed by the community.","title":"Solutions"},{"location":"solutions/GlossaryAuthor/GlossaryAuthorGuide/","text":"Glossary Author \u00b6 The Glossary Author is a UI capability of the Egeria React UI that allows you to author glossary content, such as Glossaries, Terms, Categories and the relationships between them. 1. Concepts \u00b6 Egeria has subject area open types that are described in Area 3 . This mature model of glossary content describes the relevant concepts around glossaries. The Glossary Author exposes concepts (json objects) that map onto the open types. The Glossary Author concepts are intended to make it easier for a user interface to author glossaries. As metadata is often best thought of as a graph; the Glossary author user interface exposes the concept of a Graph containing only the concepts relevant to a glossary author. The Graph is composed of Nodes (vertices) and Relationships (edges). Glossary, Category and Term are all types of Node. The Node object contains standard Egeria properties including: Name - name to be displayed. qualfied name - readable unique name guid - global unique identifier. Glossary Author Node inheritance model, including the nodes that inherit from Term , Category and Glossary. 2. Working with the Glossary Author user interface. \u00b6 2.1 Getting to the Glossary Author start screen \u00b6 After logging into the Egeria react UI, you will see tasks at the left hand side of the user interface including the glossary author task. If you see a screen with a connect button, then the glossary author is not able to issue a successfully glossary call; this is caused by either the Subject Area OMAS is not active, so the glossary author cannot call it the glossary author view is not configured on the view server. the presentation server is not configured to point to the glossary server view service. If everythign is correctly configured but the view server or its downstream server is not started then, start them and press the connect button. Assuming you have successfully connected, then you are now in a position to author glossary content You will notice that you can choose the node to work with using the node tabs. 2.2 Add a glossary \u00b6 Add a node on a tab using the add (+) button. Pressing add for glossary will show a form to input properties. The minimal input is a name. ## 2.3 Working with a glossary - Navigating back after having created a glossary called 'glossary1' in an empty system, will show one glossary in a 'card view' - 'List view' You can toggle the glossary view to show the glossaries as a list - 'paging' - notice the paging options, these allow you to change the page size (how many are displayed), page through the results if there is more than a page's worth to display. - 'filter' Entering text into the filter box, filters the displayed results. If you want an exact match, check the exact match box. 2.4 Buttons that appear when a node is selected \u00b6 Note that there is a checkbox on the node card; when checked, buttons appear indicating actions you can perform against the selected node: Quickterms button - this is shown for glossary, to quickly create Terms under the selected glossary Children button - this shows the children of the selected node. edit button - this displays an edit screen for the selected node delete button - this deletes the selected node. Glossaries with content cannot be deleted. glove button - visualisation described later 2.5 Quick terms \u00b6 The quick term screen lists the terms to be added. Initially it is empty Press the + button to add extra rows fill in the name and description in the rows press Create Terms on Server button to show a screen indicaing whetehr the terms have been created or not. 3. Working with Categories and Terms \u00b6 Working with Categories and terms, is similar to working with Glossaries, apart from - choosing the Term or Category node tab, Terms or Categories can be created, in this case a wizard is displayed to aske the user to choose the glossary in which the term should be created. 4. Glossary children \u00b6 When the glossary children action is chosen, the categories and terms under that glossary are displayed. By default top categories are displayed, these are categories that do not have a parent category. If you want to see the all the categories under the glossary then toggle the Top Categories to All Categories 5. Breadcrumb \u00b6 While navigating, a breadcrumb is created showing how deep the current node is that is being authored. 6. Glove \u00b6 Glove is a visualisation that can be displayed when there is a selected node, it displays a canvas with the single node on it.It is then possible to * explore from the node to other glossary content. * Author new relationsips and nodes * search and add new nodes to the canvas 7. Future improvements \u00b6 a breadcrumb to be optimized to minimize the url length. add governance classification authoring add spine object views add collaboration authoring and viewing start with a context from the community profile.","title":"GlossaryAuthorGuide"},{"location":"solutions/GlossaryAuthor/GlossaryAuthorGuide/#glossary-author","text":"The Glossary Author is a UI capability of the Egeria React UI that allows you to author glossary content, such as Glossaries, Terms, Categories and the relationships between them.","title":"Glossary Author"},{"location":"solutions/GlossaryAuthor/GlossaryAuthorGuide/#1-concepts","text":"Egeria has subject area open types that are described in Area 3 . This mature model of glossary content describes the relevant concepts around glossaries. The Glossary Author exposes concepts (json objects) that map onto the open types. The Glossary Author concepts are intended to make it easier for a user interface to author glossaries. As metadata is often best thought of as a graph; the Glossary author user interface exposes the concept of a Graph containing only the concepts relevant to a glossary author. The Graph is composed of Nodes (vertices) and Relationships (edges). Glossary, Category and Term are all types of Node. The Node object contains standard Egeria properties including: Name - name to be displayed. qualfied name - readable unique name guid - global unique identifier. Glossary Author Node inheritance model, including the nodes that inherit from Term , Category and Glossary.","title":"1. Concepts"},{"location":"solutions/GlossaryAuthor/GlossaryAuthorGuide/#2-working-with-the-glossary-author-user-interface","text":"","title":"2. Working with the Glossary Author user interface."},{"location":"solutions/GlossaryAuthor/GlossaryAuthorGuide/#21-getting-to-the-glossary-author-start-screen","text":"After logging into the Egeria react UI, you will see tasks at the left hand side of the user interface including the glossary author task. If you see a screen with a connect button, then the glossary author is not able to issue a successfully glossary call; this is caused by either the Subject Area OMAS is not active, so the glossary author cannot call it the glossary author view is not configured on the view server. the presentation server is not configured to point to the glossary server view service. If everythign is correctly configured but the view server or its downstream server is not started then, start them and press the connect button. Assuming you have successfully connected, then you are now in a position to author glossary content You will notice that you can choose the node to work with using the node tabs.","title":"2.1 Getting to the Glossary Author start screen"},{"location":"solutions/GlossaryAuthor/GlossaryAuthorGuide/#22-add-a-glossary","text":"Add a node on a tab using the add (+) button. Pressing add for glossary will show a form to input properties. The minimal input is a name. ## 2.3 Working with a glossary - Navigating back after having created a glossary called 'glossary1' in an empty system, will show one glossary in a 'card view' - 'List view' You can toggle the glossary view to show the glossaries as a list - 'paging' - notice the paging options, these allow you to change the page size (how many are displayed), page through the results if there is more than a page's worth to display. - 'filter' Entering text into the filter box, filters the displayed results. If you want an exact match, check the exact match box.","title":"2.2 Add a glossary"},{"location":"solutions/GlossaryAuthor/GlossaryAuthorGuide/#24-buttons-that-appear-when-a-node-is-selected","text":"Note that there is a checkbox on the node card; when checked, buttons appear indicating actions you can perform against the selected node: Quickterms button - this is shown for glossary, to quickly create Terms under the selected glossary Children button - this shows the children of the selected node. edit button - this displays an edit screen for the selected node delete button - this deletes the selected node. Glossaries with content cannot be deleted. glove button - visualisation described later","title":"2.4 Buttons that appear when a node is selected"},{"location":"solutions/GlossaryAuthor/GlossaryAuthorGuide/#25-quick-terms","text":"The quick term screen lists the terms to be added. Initially it is empty Press the + button to add extra rows fill in the name and description in the rows press Create Terms on Server button to show a screen indicaing whetehr the terms have been created or not.","title":"2.5 Quick terms"},{"location":"solutions/GlossaryAuthor/GlossaryAuthorGuide/#3-working-with-categories-and-terms","text":"Working with Categories and terms, is similar to working with Glossaries, apart from - choosing the Term or Category node tab, Terms or Categories can be created, in this case a wizard is displayed to aske the user to choose the glossary in which the term should be created.","title":"3. Working with Categories and Terms"},{"location":"solutions/GlossaryAuthor/GlossaryAuthorGuide/#4-glossary-children","text":"When the glossary children action is chosen, the categories and terms under that glossary are displayed. By default top categories are displayed, these are categories that do not have a parent category. If you want to see the all the categories under the glossary then toggle the Top Categories to All Categories","title":"4. Glossary children"},{"location":"solutions/GlossaryAuthor/GlossaryAuthorGuide/#5-breadcrumb","text":"While navigating, a breadcrumb is created showing how deep the current node is that is being authored.","title":"5. Breadcrumb"},{"location":"solutions/GlossaryAuthor/GlossaryAuthorGuide/#6-glove","text":"Glove is a visualisation that can be displayed when there is a selected node, it displays a canvas with the single node on it.It is then possible to * explore from the node to other glossary content. * Author new relationsips and nodes * search and add new nodes to the canvas","title":"6. Glove"},{"location":"solutions/GlossaryAuthor/GlossaryAuthorGuide/#7-future-improvements","text":"a breadcrumb to be optimized to minimize the url length. add governance classification authoring add spine object views add collaboration authoring and viewing start with a context from the community profile.","title":"7. Future improvements"}]}